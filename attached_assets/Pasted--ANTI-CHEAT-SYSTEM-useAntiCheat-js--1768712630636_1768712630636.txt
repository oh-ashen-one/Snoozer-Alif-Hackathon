/**
 * ANTI-CHEAT SYSTEM
 * useAntiCheat.js
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * PROTECTION LAYERS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ LAYER 1: Power Off Prevention                              â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ â€¢ Save alarm state to AsyncStorage every 10 seconds        â”‚
 * â”‚ â€¢ On app launch, check for interrupted alarms              â”‚
 * â”‚ â€¢ If found: immediately restart alarm + add penalty        â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *                              â†“
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ LAYER 2: App Kill Detection                                â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ â€¢ Background notification scheduled when alarm starts      â”‚
 * â”‚ â€¢ If app killed, notification still fires                  â”‚
 * â”‚ â€¢ Notification tap â†’ reopens app â†’ alarm resumes           â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *                              â†“
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ LAYER 3: Photo Freshness Check                             â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ â€¢ Proof photo must be taken within last 60 seconds         â”‚
 * â”‚ â€¢ Check EXIF timestamp if available                        â”‚
 * â”‚ â€¢ Camera must be used (no gallery picks)                   â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *                              â†“
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ LAYER 4: Shake Detection (for step mission)                â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ â€¢ Monitor accelerometer during step counting               â”‚
 * â”‚ â€¢ Flag rapid irregular movements as "shaking"              â”‚
 * â”‚ â€¢ Shaking = steps don't count + warning                    â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *                              â†“
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ LAYER 5: Time Manipulation Check                           â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ â€¢ Compare device time vs server time (if online)           â”‚
 * â”‚ â€¢ Flag if device time changed during alarm                 â”‚
 * â”‚ â€¢ Prevent "set clock forward" cheats                       â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { useEffect, useRef, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Notifications from 'expo-notifications';
import { AppState } from 'react-native';

const ALARM_STATE_KEY = '@snoozer_active_alarm';
const HEARTBEAT_INTERVAL = 10000; // 10 seconds

export function useAntiCheat({ onCheatDetected, onAlarmInterrupted }) {
  const heartbeatInterval = useRef(null);
  const appState = useRef(AppState.currentState);
  const alarmStartTime = useRef(null);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LAYER 1: Power Off Prevention
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  const saveAlarmState = useCallback(async (alarmData) => {
    try {
      await AsyncStorage.setItem(ALARM_STATE_KEY, JSON.stringify({
        ...alarmData,
        lastHeartbeat: Date.now(),
        startedAt: alarmStartTime.current,
      }));
    } catch (error) {
      console.error('Failed to save alarm state:', error);
    }
  }, []);

  const clearAlarmState = useCallback(async () => {
    try {
      await AsyncStorage.removeItem(ALARM_STATE_KEY);
    } catch (error) {
      console.error('Failed to clear alarm state:', error);
    }
  }, []);

  const checkForInterruptedAlarm = useCallback(async () => {
    try {
      const stored = await AsyncStorage.getItem(ALARM_STATE_KEY);
      if (stored) {
        const alarmState = JSON.parse(stored);
        const timeSinceHeartbeat = Date.now() - alarmState.lastHeartbeat;
        
        // If last heartbeat was more than 30 seconds ago, alarm was interrupted
        if (timeSinceHeartbeat > 30000) {
          onAlarmInterrupted?.(alarmState);
          return alarmState;
        }
      }
      return null;
    } catch (error) {
      console.error('Failed to check interrupted alarm:', error);
      return null;
    }
  }, [onAlarmInterrupted]);

  // Start heartbeat when alarm is active
  const startHeartbeat = useCallback((alarmData) => {
    alarmStartTime.current = Date.now();
    
    // Immediate save
    saveAlarmState(alarmData);
    
    // Regular heartbeat
    heartbeatInterval.current = setInterval(() => {
      saveAlarmState(alarmData);
    }, HEARTBEAT_INTERVAL);
  }, [saveAlarmState]);

  const stopHeartbeat = useCallback(() => {
    clearInterval(heartbeatInterval.current);
    clearAlarmState();
    alarmStartTime.current = null;
  }, [clearAlarmState]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LAYER 2: App Kill Detection
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const scheduleBackupNotification = useCallback(async (alarmData) => {
    // Schedule a notification that will fire if app is killed
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "âš ï¸ Nice try!",
        body: "Your alarm is still waiting. Open Snoozer now.",
        sound: true,
        priority: Notifications.AndroidNotificationPriority.MAX,
        sticky: true,
      },
      trigger: { seconds: 60 }, // Fires 1 min after scheduling
      identifier: 'backup-alarm',
    });
  }, []);

  const cancelBackupNotification = useCallback(async () => {
    await Notifications.cancelScheduledNotificationAsync('backup-alarm');
  }, []);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LAYER 3: Photo Freshness Check
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const validatePhotoFreshness = useCallback((photoTimestamp) => {
    const now = Date.now();
    const age = now - photoTimestamp;
    const MAX_AGE = 60000; // 60 seconds

    if (age > MAX_AGE) {
      onCheatDetected?.('photo_too_old');
      return false;
    }
    return true;
  }, [onCheatDetected]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LAYER 5: Time Manipulation Check
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const validateTimeIntegrity = useCallback(async () => {
    if (!alarmStartTime.current) return true;

    const elapsed = Date.now() - alarmStartTime.current;
    
    // If "elapsed" time is negative or way too long, time was manipulated
    if (elapsed < 0 || elapsed > 24 * 60 * 60 * 1000) {
      onCheatDetected?.('time_manipulation');
      return false;
    }

    // Optional: Compare with server time
    // try {
    //   const response = await fetch('https://worldtimeapi.org/api/ip');
    //   const data = await response.json();
    //   const serverTime = new Date(data.utc_datetime).getTime();
    //   const drift = Math.abs(Date.now() - serverTime);
    //   if (drift > 60000) { // More than 1 minute drift
    //     onCheatDetected?.('clock_drift');
    //     return false;
    //   }
    // } catch (e) {
    //   // Offline, skip server check
    // }

    return true;
  }, [onCheatDetected]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // App State Monitoring
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  useEffect(() => {
    const subscription = AppState.addEventListener('change', (nextAppState) => {
      if (appState.current === 'active' && nextAppState.match(/inactive|background/)) {
        // App going to background - schedule backup
        // scheduleBackupNotification();
      }
      appState.current = nextAppState;
    });

    // Check for interrupted alarm on mount
    checkForInterruptedAlarm();

    return () => {
      subscription?.remove();
      clearInterval(heartbeatInterval.current);
    };
  }, [checkForInterruptedAlarm]);

  return {
    // Layer 1: Power off prevention
    startHeartbeat,
    stopHeartbeat,
    checkForInterruptedAlarm,
    
    // Layer 2: App kill detection
    scheduleBackupNotification,
    cancelBackupNotification,
    
    // Layer 3: Photo freshness
    validatePhotoFreshness,
    
    // Layer 5: Time manipulation
    validateTimeIntegrity,
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPONENT: CheatWarningModal.jsx
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { View, Text, StyleSheet, Modal, TouchableOpacity } from 'react-native';

const CHEAT_MESSAGES = {
  photo_too_old: {
    emoji: 'ğŸ“¸',
    title: 'Nice try, time traveler',
    message: 'That photo is too old. Take a fresh one.',
  },
  time_manipulation: {
    emoji: 'â°',
    title: 'Clock manipulation detected',
    message: "Changing your phone's time won't work here.",
  },
  app_killed: {
    emoji: 'ğŸ’€',
    title: 'App killed? Really?',
    message: "Your alarm doesn't care. It's back.",
  },
  shake_detected: {
    emoji: 'ğŸ«¨',
    title: 'Shaking detected',
    message: "Walk, don't shake. Those steps don't count.",
  },
};

export function CheatWarningModal({ visible, cheatType, onDismiss }) {
  const content = CHEAT_MESSAGES[cheatType] || CHEAT_MESSAGES.app_killed;

  return (
    <Modal visible={visible} animationType="fade" transparent>
      <View style={cheatStyles.overlay}>
        <View style={cheatStyles.container}>
          <Text style={cheatStyles.emoji}>{content.emoji}</Text>
          <Text style={cheatStyles.title}>{content.title}</Text>
          <Text style={cheatStyles.message}>{content.message}</Text>
          
          <TouchableOpacity style={cheatStyles.button} onPress={onDismiss}>
            <Text style={cheatStyles.buttonText}>Fine. I'll do it properly.</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}

const cheatStyles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 24,
  },
  container: {
    backgroundColor: '#1C1917',
    borderRadius: 24,
    padding: 32,
    width: '100%',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#EF4444',
  },
  emoji: {
    fontSize: 64,
    marginBottom: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: '#EF4444',
    marginBottom: 8,
    textAlign: 'center',
  },
  message: {
    fontSize: 16,
    color: '#A8A29E',
    textAlign: 'center',
    marginBottom: 32,
    lineHeight: 24,
  },
  button: {
    backgroundColor: '#292524',
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 14,
    width: '100%',
    alignItems: 'center',
  },
  buttonText: {
    color: '#FAFAF9',
    fontSize: 16,
    fontWeight: '600',
  },
});